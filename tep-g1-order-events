warning: in the working copy of '.gitignore', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'README.md', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'config/strategies.yaml', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'pyproject.toml', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'requirements.txt', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/cli/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/cli/migrate.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/cli/rebuild_analytics.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/cli/retention.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/engine/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/engine/instance.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/engine/runner.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/models/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/models/enums.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/models/order.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/models/position.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/oms/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/oms/events.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/oms/metrics_reporter.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/oms/oms.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/oms/parser.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/oms/preflight.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/oms/reconcile.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/oms/state_machine.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/oms/utils.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/oms/writer.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/orders/models.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/position/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/position/aggregator.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/position/position_state.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/risk/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/risk/risk_engine.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/strategy/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/strategy/base.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/strategy/example_nohedge.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/strategy/one_shot_test.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/utils/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/core/utils/idempotency.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/data/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/data/orders_repository.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/data/retention/retention_worker.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/data/storage/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/data/storage/base.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/data/storage/postgres/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/data/storage/postgres/ddl.sql', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/data/storage/postgres/pool.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/data/storage/postgres/storage.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/data/storage/postgres_storage.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/base/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/base/exchange.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/binance/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/binance/collector_exchange_info.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/binance/collector_symbol_filters.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/binance/exchange.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/binance/filters.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/binance/normalize.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/binance/oms_rest.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/binance/order_normalizer.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/binance/parsers/symbol_filters.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/binance/rest.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/binance/ws.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/exchanges/registry.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/ledger/fills_ingest.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/ledger/fills_store.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/ledger/models.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/market_state/__init__.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/market_state/models.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/market_state/pollers/balance_poller.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/market_state/pollers/oi_poller.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/market_state/reader.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/market_state/retention.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/market_state/snapshots.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/market_state/state_reader.py', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/migrations/XXXX_create_orders.sql', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/platform/run_instances.py', LF will be replaced by CRLF the next time Git touches it
[1mdiff --git a/src/platform/core/engine/instance.py b/src/platform/core/engine/instance.py[m
[1mindex 684dd96..92c6b54 100644[m
[1m--- a/src/platform/core/engine/instance.py[m
[1m+++ b/src/platform/core/engine/instance.py[m
[36m@@ -178,6 +178,9 @@[m [mclass TradingInstance:[m
                 event,[m
                 exchange=self.exchange.name,[m
                 account=self.account,[m
[32m+[m[32m                exchange_id=self.exchange_id,[m
[32m+[m[32m                account_id=self.account_id,[m
[32m+[m[32m                symbol_ids=self.symbol_ids,[m
             )[m
 [m
             for ev in events:[m
[1mdiff --git a/src/platform/core/oms/events.py b/src/platform/core/oms/events.py[m
[1mindex c1585db..7f71ef0 100644[m
[1m--- a/src/platform/core/oms/events.py[m
[1m+++ b/src/platform/core/oms/events.py[m
[36m@@ -1,45 +1,106 @@[m
 # src/platform/core/oms/events.py[m
 from __future__ import annotations[m
[32m+[m
 from dataclasses import dataclass[m
[31m-from enum import Enum[m
[31m-from typing import Optional[m
[32m+[m[32mfrom datetime import datetime, timezone[m
[32m+[m[32mfrom typing import Any[m
 [m
 [m
[31m-class OrderStatus(str, Enum):[m
[31m-    NEW = "NEW"[m
[31m-    PARTIALLY_FILLED = "PARTIALLY_FILLED"[m
[31m-    FILLED = "FILLED"[m
[31m-    CANCELED = "CANCELED"[m
[31m-    EXPIRED = "EXPIRED"[m
[31m-    REJECTED = "REJECTED"[m
[32m+[m[32mdef _utcnow() -> datetime:[m
[32m+[m[32m    return datetime.now(tz=timezone.utc)[m
 [m
 [m
[31m-@dataclass(frozen=True)[m
[32m+[m[32m@dataclass(slots=True)[m
 class OrderEvent:[m
[32m+[m[32m    """Normalized OMS order event (from WS/REST).[m
[32m+[m
[32m+[m[32m    IMPORTANT: This is a *fact* event coming from exchange. No business logic here.[m
[32m+[m[32m    """[m
     exchange: str[m
     account: str[m
     symbol: str[m
[31m-    order_id: int[m
[31m-    client_order_id: Optional[str][m
[31m-    status: OrderStatus[m
[31m-    side: str[m
[31m-    price: float[m
[31m-    qty: float[m
[31m-    filled_qty: float[m
[31m-    event_ts: float[m
 [m
[32m+[m[32m    exchange_id: int[m
[32m+[m[32m    account_id: int[m
[32m+[m[32m    symbol_id: int[m
[32m+[m
[32m+[m[32m    order_id: str[m
[32m+[m[32m    client_order_id: str | None[m
[32m+[m
[32m+[m[32m    status: str                 # NEW / PARTIALLY_FILLED / FILLED / CANCELED / REJECTED / EXPIRED / ...[m
[32m+[m[32m    side: str | None            # BUY / SELL[m
[32m+[m[32m    type: str | None            # LIMIT / MARKET / STOP / ...[m
[32m+[m[32m    reduce_only: bool = False[m
[32m+[m
[32m+[m[32m    price: float | None = None[m
[32m+[m[32m    qty: float | None = None[m
[32m+[m[32m    filled_qty: float | None = None[m
[32m+[m
[32m+[m[32m    source: str = "ws_user"     # ws_user / rest / etc[m
[32m+[m
[32m+[m[32m    ts_ms: int = 0              # exchange event time in ms (best effort)[m
[32m+[m[32m    recv_ts: datetime | None = None[m
[32m+[m
[32m+[m[32m    raw: dict[str, Any] | None = None[m
[32m+[m
[32m+[m[32m    def ensure_recv_ts(self) -> datetime:[m
[32m+[m[32m        if self.recv_ts is None:[m
[32m+[m[32m            self.recv_ts = _utcnow()[m
[32m+[m[32m        return self.recv_ts[m
 [m
[31m-@dataclass(frozen=True)[m
[32m+[m
[32m+[m[32m@dataclass(slots=True)[m
 class TradeEvent:[m
[32m+[m[32m    """Normalized OMS trade(fill) event."""[m
     exchange: str[m
     account: str[m
     symbol: str[m
[31m-    trade_id: int[m
[31m-    order_id: int[m
[31m-    side: str[m
[32m+[m
[32m+[m[32m    exchange_id: int[m
[32m+[m[32m    account_id: int[m
[32m+[m[32m    symbol_id: int[m
[32m+[m
[32m+[m[32m    trade_id: str[m
[32m+[m[32m    order_id: str[m
[32m+[m
[32m+[m[32m    side: str | None[m
     price: float[m
     qty: float[m
[31m-    realized_pnl: float[m
[31m-    fee: float[m
[31m-    fee_asset: str[m
[31m-    event_ts: float[m
[32m+[m
[32m+[m[32m    realized_pnl: float | None = None[m
[32m+[m[32m    fee: float | None = None[m
[32m+[m[32m    fee_asset: str | None = None[m
[32m+[m
[32m+[m[32m    source: str = "ws_user"[m
[32m+[m
[32m+[m[32m    ts_ms: int = 0[m
[32m+[m[32m    recv_ts: datetime | None = None[m
[32m+[m
[32m+[m[32m    raw: dict[str, Any] | None = None[m
[32m+[m
[32m+[m[32m    def ensure_recv_ts(self) -> datetime:[m
[32m+[m[32m        if self.recv_ts is None:[m
[32m+[m[32m            self.recv_ts = _utcnow()[m
[32m+[m[32m        return self.recv_ts[m
[32m+[m
[32m+[m[32m    def to_row(self) -> dict[str, Any]:[m
[32m+[m[32m        self.ensure_recv_ts()[m
[32m+[m[32m        # storage.trades expects TIMESTAMPTZ 'ts'[m
[32m+[m[32m        ts = datetime.fromtimestamp((self.ts_ms or 0) / 1000.0, tz=timezone.utc)[m
[32m+[m[32m        return {[m
[32m+[m[32m            "exchange_id": int(self.exchange_id),[m
[32m+[m[32m            "account_id": int(self.account_id),[m
[32m+[m[32m            "trade_id": str(self.trade_id),[m
[32m+[m[32m            "order_id": str(self.order_id or ""),[m
[32m+[m[32m            "symbol_id": int(self.symbol_id),[m
[32m+[m[32m            "strategy_id": "unknown",[m
[32m+[m[32m            "pos_uid": None,[m
[32m+[m[32m            "side": str(self.side or ""),[m
[32m+[m[32m            "price": float(self.price),[m
[32m+[m[32m            "qty": float(self.qty),[m
[32m+[m[32m            "fee": float(self.fee or 0.0),[m
[32m+[m[32m            "fee_asset": str(self.fee_asset or ""),[m
[32m+[m[32m            "realized_pnl": float(self.realized_pnl or 0.0),[m
[32m+[m[32m            "ts": ts,[m
[32m+[m[32m            "source": str(self.source or "ws_user"),[m
[32m+[m[32m        }[m
[1mdiff --git a/src/platform/core/oms/oms.py b/src/platform/core/oms/oms.py[m
[1mindex 4eeb9a6..4acae8e 100644[m
[1m--- a/src/platform/core/oms/oms.py[m
[1m+++ b/src/platform/core/oms/oms.py[m
[36m@@ -1,116 +1,79 @@[m
[32m+[m[32m# src/platform/core/oms/oms.py[m
 from __future__ import annotations[m
 [m
 import time[m
[32m+[m[32mimport logging[m
 from dataclasses import dataclass[m
[31m-from typing import Optional[m
[32m+[m[32mfrom typing import Optional, Iterable[m
 [m
 from src.platform.core.models.order import OrderIntent[m
 from src.platform.core.oms.events import OrderEvent, TradeEvent[m
 from src.platform.core.oms.preflight import preflight_intent[m
[32m+[m[32mfrom src.platform.core.oms.writer import OmsWriter[m
 [m
 [m
 _FINAL_STATUSES = {"FILLED", "CANCELED", "REJECTED", "EXPIRED"}[m
 [m
 [m
 # ----------------------------------------------------------------------[m
[31m-# Pending submit placeholder[m
[32m+[m[32m# Pending submit placeholder (idempotency / WS gaps)[m
 # ----------------------------------------------------------------------[m
[31m-[m
[31m-@dataclass[m
[32m+[m[32m@dataclass(slots=True)[m
 class PendingSubmit:[m
     client_order_id: str[m
     symbol_id: int[m
     strategy_id: str[m
[31m-    pos_uid: str[m
[32m+[m[32m    pos_uid: str | None[m
     intent: OrderIntent[m
     created_ts: float[m
 [m
 [m
[31m-# ----------------------------------------------------------------------[m
[31m-# OMS[m
[31m-# ----------------------------------------------------------------------[m
[31m-[m
 class OrderManager:[m
[31m-    """[m
[31m-    OMS â€” Order State Manager[m
[31m-[m
[31m-    STEP E.2 responsibilities:[m
[31m-      - preflight (symbol_filters + normalize)[m
[31m-      - idempotency gating[m
[31m-      - pending placeholders[m
[31m-      - consume WS order/trade events[m
[31m-      - pending timeout cleanup[m
[32m+[m[32m    """Minimal OMS layer.[m
[32m+[m
[32m+[m[32m    STEP G.1 goal:[m
[32m+[m[32m      - accept WS user events (OrderEvent / TradeEvent)[m
[32m+[m[32m      - persist events into DB (order_events + trades)[m
[32m+[m[32m      - keep a tiny idempotency gate for client_order_id[m
[32m+[m
[32m+[m[32m    Full aggregate/FSM (STEP G.2) will be added later.[m
     """[m
 [m
[31m-    def __init__(self, *, storage, exchange_id: int, account_id: int):[m
[32m+[m[32m    def __init__([m
[32m+[m[32m        self,[m
[32m+[m[32m        *,[m
[32m+[m[32m        storage,[m
[32m+[m[32m        exchange_id: int,[m
[32m+[m[32m        account_id: int,[m
[32m+[m[32m        logger: logging.Logger | None = None,[m
[32m+[m[32m    ) -> None:[m
         self.storage = storage[m
         self.exchange_id = int(exchange_id)[m
         self.account_id = int(account_id)[m
[32m+[m[32m        self.logger = logger or logging.getLogger(__name__)[m
[32m+[m
[32m+[m[32m        self.writer = OmsWriter(storage=self.storage, oms=self, logger=self.logger)[m
 [m
         # cid -> PendingSubmit[m
         self._pending: dict[str, PendingSubmit] = {}[m
 [m
[31m-        # cid -> ts (final status seen)[m
[31m-        self._final_seen: dict[str, float] = {}[m
[31m-[m
[31m-        # cid -> last known status[m
[32m+[m[32m        # cid -> last seen status (debug)[m
         self._last_status: dict[str, str] = {}[m
 [m
[31m-    # ------------------------------------------------------------------[m
[31m-    # STEP D â€” PREFLIGHT[m
[31m-    # ------------------------------------------------------------------[m
[31m-[m
[31m-    def preflight([m
[31m-        self,[m
[31m-        *,[m
[31m-        symbol: str,[m
[31m-        symbol_id: int,[m
[31m-        intent: OrderIntent,[m
[31m-        last_price: float,[m
[31m-        logger=None,[m
[31m-    ) -> Optional[OrderIntent]:[m
[31m-        """[m
[31m-        Normalize qty/price using symbol_filters.[m
[31m-        Return normalized intent or None (skip).[m
[31m-        """[m
[31m-        try:[m
[31m-            filters = self.storage.get_symbol_filters([m
[31m-                exchange_id=self.exchange_id,[m
[31m-                symbol_id=int(symbol_id),[m
[31m-            )[m
[31m-        except KeyError:[m
[31m-            if logger:[m
[31m-                logger.warning("[OMS][PREFLIGHT] no symbol_filters for %s â†’ skip", symbol)[m
[31m-            return None[m
[31m-        except Exception as e:[m
[31m-            if logger:[m
[31m-                logger.warning("[OMS][PREFLIGHT] error loading filters for %s: %s", symbol, e)[m
[31m-            return None[m
[31m-[m
[31m-        return preflight_intent([m
[31m-            intent,[m
[31m-            filters=filters,[m
[31m-            last_price=float(last_price),[m
[31m-            logger=logger,[m
[31m-        )[m
[32m+[m[32m        # cid -> ts when we saw final status (idempotency)[m
[32m+[m[32m        self._final_seen: dict[str, float] = {}[m
 [m
     # ------------------------------------------------------------------[m
[31m-    # Idempotency[m
[32m+[m[32m    # submit-side helpers[m
     # ------------------------------------------------------------------[m
[31m-[m
     def should_submit(self, client_order_id: str) -> bool:[m
[31m-        """[m
[31m-        Decide whether we are allowed to submit this CID.[m
[31m-        """[m
[32m+[m[32m        """Simple idempotency: don't submit same CID twice."""[m
         if not client_order_id:[m
[31m-            return False[m
[31m-[m
[32m+[m[32m            return True[m
         if client_order_id in self._pending:[m
             return False[m
[31m-[m
         if client_order_id in self._final_seen:[m
             return False[m
[31m-[m
         return True[m
 [m
     def record_pending_submit([m
[36m@@ -119,30 +82,27 @@[m [mclass OrderManager:[m
         client_order_id: str,[m
         symbol_id: int,[m
         strategy_id: str,[m
[31m-        pos_uid: str,[m
[32m+[m[32m        pos_uid: str | None,[m
         intent: OrderIntent,[m
     ) -> None:[m
[31m-        """[m
[31m-        Register placeholder before sending order to exchange.[m
[31m-        """[m
[32m+[m[32m        if not client_order_id:[m
[32m+[m[32m            return[m
         self._pending[client_order_id] = PendingSubmit([m
             client_order_id=client_order_id,[m
             symbol_id=int(symbol_id),[m
[31m-            strategy_id=str(strategy_id),[m
[31m-            pos_uid=str(pos_uid),[m
[32m+[m[32m            strategy_id=str(strategy_id or "unknown"),[m
[32m+[m[32m            pos_uid=str(pos_uid) if pos_uid else None,[m
             intent=intent,[m
             created_ts=time.time(),[m
         )[m
 [m
     def reconcile_pending_timeouts(self, timeout_sec: float) -> int:[m
[31m-        """[m
[31m-        Drop pending orders that never received WS/REST confirmation.[m
[31m-        """[m
[32m+[m[32m        """Drop pending orders that never received WS/REST confirmation."""[m
         now = time.time()[m
         timeout = float(timeout_sec or 20)[m
 [m
         expired: list[str] = [][m
[31m-        for cid, p in self._pending.items():[m
[32m+[m[32m        for cid, p in list(self._pending.items()):[m
             if now - p.created_ts >= timeout:[m
                 expired.append(cid)[m
 [m
[36m@@ -154,31 +114,65 @@[m [mclass OrderManager:[m
         return len(expired)[m
 [m
     # ------------------------------------------------------------------[m
[31m-    # STEP E.2 â€” consume events[m
[32m+[m[32m    # event ingestion[m
     # ------------------------------------------------------------------[m
[32m+[m[32m    def apply_event(self, ev: object) -> None:[m
[32m+[m[32m        if isinstance(ev, OrderEvent):[m
[32m+[m[32m            self.on_order_event(ev)[m
[32m+[m[32m            return[m
[32m+[m[32m        if isinstance(ev, TradeEvent):[m
[32m+[m[32m            self.on_trade_event(ev)[m
[32m+[m[32m            return[m
[32m+[m[32m        self.logger.debug("[OMS] ignored unknown event=%s", type(ev))[m
 [m
     def on_order_event(self, evt: OrderEvent) -> None:[m
[31m-        """[m
[31m-        Consume ORDER_TRADE_UPDATE (order part).[m
[31m-        """[m
[31m-        cid = evt.client_order_id or ""[m
[31m-        if not cid:[m
[31m-            return[m
[32m+[m[32m        """Consume order status update."""[m
[32m+[m[32m        # ensure ids match current instance (safety)[m
[32m+[m[32m        evt.exchange_id = int(evt.exchange_id or self.exchange_id)[m
[32m+[m[32m        evt.account_id = int(evt.account_id or self.account_id)[m
 [m
[31m-        status = (evt.status or "").upper()[m
[31m-        if status:[m
[31m-            self._last_status[cid] = status[m
[32m+[m[32m        self.writer.write_order(evt)[m
 [m
[31m-        # Final status closes pending[m
[31m-        if status in _FINAL_STATUSES:[m
[31m-            self._pending.pop(cid, None)[m
[31m-            self._final_seen[cid] = time.time()[m
[32m+[m[32m        cid = str(evt.client_order_id or "")[m
[32m+[m[32m        status = str(evt.status or "").upper()[m
[32m+[m[32m        if cid:[m
[32m+[m[32m            self._last_status[cid] = status[m
[32m+[m[32m            if status in _FINAL_STATUSES:[m
[32m+[m[32m                self._pending.pop(cid, None)[m
[32m+[m[32m                self._final_seen[cid] = time.time()[m
 [m
     def on_trade_event(self, evt: TradeEvent) -> None:[m
[31m-        """[m
[31m-        Consume execution (trade).[m
[31m-        Trades do NOT finalize order â€” only status does.[m
[31m-        """[m
[31m-        # For now we only record via storage layer[m
[31m-        # (PnL / positions will be STEP H)[m
[31m-        return[m
[32m+[m[32m        """Consume trade(fill) event."""[m
[32m+[m[32m        evt.exchange_id = int(evt.exchange_id or self.exchange_id)[m
[32m+[m[32m        evt.account_id = int(evt.account_id or self.account_id)[m
[32m+[m[32m        self.writer.write_trade(evt)[m
[32m+[m
[32m+[m[32m    # ------------------------------------------------------------------[m
[32m+[m[32m    # submit preflight[m
[32m+[m[32m    # ------------------------------------------------------------------[m
[32m+[m[32m    def preflight([m
[32m+[m[32m        self,[m
[32m+[m[32m        *,[m
[32m+[m[32m        symbol: str,[m
[32m+[m[32m        symbol_id: int,[m
[32m+[m[32m        intent: OrderIntent,[m
[32m+[m[32m        last_price: float,[m
[32m+[m[32m        logger=None,[m
[32m+[m[32m    ) -> Optional[OrderIntent]:[m
[32m+[m[32m        """Normalize intent (qty/price rounding, minNotional, etc)."""[m
[32m+[m[32m        try:[m
[32m+[m[32m            filters = self.storage.get_symbol_filters([m
[32m+[m[32m                exchange_id=self.exchange_id,[m
[32m+[m[32m                symbol_id=int(symbol_id),[m
[32m+[m[32m            )[m
[32m+[m[32m        except Exception:[m
[32m+[m[32m            self.logger.exception("[OMS][Preflight] get_symbol_filters failed symbol=%s", symbol)[m
[32m+[m[32m            return None[m
[32m+[m
[32m+[m[32m        return preflight_intent([m
[32m+[m[32m            symbol=symbol,[m
[32m+[m[32m            intent=intent,[m
[32m+[m[32m            last_price=float(last_price or 0.0),[m
[32m+[m[32m            filters=filters,[m
[32m+[m[32m            logger=logger or self.logger,[m
[32m+[m[32m        )[m
[1mdiff --git a/src/platform/core/oms/parser.py b/src/platform/core/oms/parser.py[m
[1mindex d5be391..6d1c28f 100644[m
[1m--- a/src/platform/core/oms/parser.py[m
[1m+++ b/src/platform/core/oms/parser.py[m
[36m@@ -1,8 +1,33 @@[m
 # src/platform/core/oms/parser.py[m
 from __future__ import annotations[m
[31m-from typing import Iterable[m
 [m
[31m-from .events import OrderEvent, TradeEvent, OrderStatus[m
[32m+[m[32mfrom typing import Iterable, Any[m
[32m+[m
[32m+[m[32mfrom .events import OrderEvent, TradeEvent[m
[32m+[m
[32m+[m
[32m+[m[32mdef _to_int_ms(v: Any) -> int:[m
[32m+[m[32m    try:[m
[32m+[m[32m        if v is None:[m
[32m+[m[32m            return 0[m
[32m+[m[32m        # already ms[m
[32m+[m[32m        if isinstance(v, (int, float)) and v > 10_000_000_000:[m
[32m+[m[32m            return int(v)[m
[32m+[m[32m        # seconds[m
[32m+[m[32m        if isinstance(v, (int, float)):[m
[32m+[m[32m            return int(float(v) * 1000.0)[m
[32m+[m[32m        return int(v)[m
[32m+[m[32m    except Exception:[m
[32m+[m[32m        return 0[m
[32m+[m
[32m+[m
[32m+[m[32mdef _f(v: Any, default: float | None = None) -> float | None:[m
[32m+[m[32m    try:[m
[32m+[m[32m        if v is None or v == "":[m
[32m+[m[32m            return default[m
[32m+[m[32m        return float(v)[m
[32m+[m[32m    except Exception:[m
[32m+[m[32m        return default[m
 [m
 [m
 def parse_binance_user_event([m
[36m@@ -10,54 +35,178 @@[m [mdef parse_binance_user_event([m
     *,[m
     exchange: str,[m
     account: str,[m
[32m+[m[32m    exchange_id: int | None = None,[m
[32m+[m[32m    account_id: int | None = None,[m
[32m+[m[32m    symbol_ids: dict[str, int] | None = None,[m
[32m+[m[32m    source: str = "ws_user",[m
 ) -> Iterable[object]:[m
[32m+[m[32m    """Parse Binance (UM Futures) USER_DATA event into OMS domain events.[m
[32m+[m
[32m+[m[32m    Supports:[m
[32m+[m[32m      - Futures: ORDER_TRADE_UPDATE (most important)[m
[32m+[m[32m      - Spot: executionReport (best-effort)[m
[32m+[m[32m    Yields: OrderEvent / TradeEvent[m
     """[m
[31m-    Parse Binance USER_DATA event into OMS domain events.[m
[31m-    Yields OrderEvent / TradeEvent.[m
[31m-    """[m
[32m+[m[32m    out: list[object] = [][m
[32m+[m
[32m+[m[32m    ex_id = int(exchange_id or 0)[m
[32m+[m[32m    acc_id = int(account_id or 0)[m
[32m+[m[32m    sym_ids = symbol_ids or {}[m
[32m+[m
[32m+[m[32m    et = (event.get("e") or event.get("eventType") or "").upper()[m
[32m+[m
[32m+[m[32m    # ------------------------------------------------------------[m
[32m+[m[32m    # Futures user stream: ORDER_TRADE_UPDATE[m
[32m+[m[32m    # https://binance-docs.github.io/apidocs/futures/en/#event-order-update[m
[32m+[m[32m    # ------------------------------------------------------------[m
[32m+[m[32m    if et == "ORDER_TRADE_UPDATE":[m
[32m+[m[32m        o = event.get("o") or {}[m
[32m+[m[32m        symbol = str(o.get("s") or "").upper()[m
[32m+[m[32m        if not symbol:[m
[32m+[m[32m            return out[m
[32m+[m
[32m+[m[32m        symbol_id = int(sym_ids.get(symbol) or 0)[m
[32m+[m
[32m+[m[32m        ts_ms = _to_int_ms(o.get("T") or event.get("E") or event.get("T"))[m
[32m+[m[32m        order_id = str(o.get("i") or "")[m
[32m+[m[32m        client_order_id = str(o.get("c") or "") or None[m
[32m+[m
[32m+[m[32m        status = str(o.get("X") or "").upper()[m
[32m+[m[32m        side = str(o.get("S") or "").upper() or None[m
[32m+[m[32m        typ = str(o.get("o") or "").upper() or None[m
[32m+[m[32m        reduce_only = bool(o.get("R") or False)[m
[32m+[m
[32m+[m[32m        qty = _f(o.get("q"), None)[m
[32m+[m[32m        filled_qty = _f(o.get("z"), None)[m
[32m+[m
[32m+[m[32m        # orig price can be 0 for market orders[m
[32m+[m[32m        price = _f(o.get("p"), None)[m
[32m+[m[32m        if price is not None and price == 0.0:[m
[32m+[m[32m            price = None[m
 [m
[31m-    if event.get("e") != "ORDER_TRADE_UPDATE":[m
[31m-        return [][m
[31m-[m
[31m-    o = event.get("o", {})[m
[31m-    ts = event.get("E", 0) / 1000[m
[31m-[m
[31m-    out = [][m
[31m-[m
[31m-    # --- OrderEvent ---[m
[31m-    out.append([m
[31m-        OrderEvent([m
[31m-            exchange=exchange,[m
[31m-            account=account,[m
[31m-            symbol=o["s"],[m
[31m-            order_id=int(o["i"]),[m
[31m-            client_order_id=o.get("c"),[m
[31m-            status=OrderStatus(o["X"]),[m
[31m-            side=o["S"],[m
[31m-            price=float(o.get("p") or 0),[m
[31m-            qty=float(o.get("q") or 0),[m
[31m-            filled_qty=float(o.get("z") or 0),[m
[31m-            event_ts=ts,[m
[32m+[m[32m        out.append([m
[32m+[m[32m            OrderEvent([m
[32m+[m[32m                exchange=exchange,[m
[32m+[m[32m                account=account,[m
[32m+[m[32m                symbol=symbol,[m
[32m+[m[32m                exchange_id=ex_id,[m
[32m+[m[32m                account_id=acc_id,[m
[32m+[m[32m                symbol_id=symbol_id,[m
[32m+[m[32m                order_id=order_id,[m
[32m+[m[32m                client_order_id=client_order_id,[m
[32m+[m[32m                status=status,[m
[32m+[m[32m                side=side,[m
[32m+[m[32m                type=typ,[m
[32m+[m[32m                reduce_only=reduce_only,[m
[32m+[m[32m                price=price,[m
[32m+[m[32m                qty=qty,[m
[32m+[m[32m                filled_qty=filled_qty,[m
[32m+[m[32m                source=source,[m
[32m+[m[32m                ts_ms=ts_ms,[m
[32m+[m[32m                raw=event,[m
[32m+[m[32m            )[m
         )[m
[31m-    )[m
 [m
[31m-    # --- TradeEvent (only if execution happened) ---[m
[31m-    if o.get("l") and float(o["l"]) > 0:[m
[32m+[m[32m        # If this update contains a trade fill (last filled qty > 0) and tradeId exists[m
[32m+[m[32m        last_qty = _f(o.get("l"), 0.0) or 0.0[m
[32m+[m[32m        trade_id = o.get("t")  # tradeId (futures)[m
[32m+[m[32m        if trade_id is not None and last_qty and float(last_qty) > 0:[m
[32m+[m[32m            out.append([m
[32m+[m[32m                TradeEvent([m
[32m+[m[32m                    exchange=exchange,[m
[32m+[m[32m                    account=account,[m
[32m+[m[32m                    symbol=symbol,[m
[32m+[m[32m                    exchange_id=ex_id,[m
[32m+[m[32m                    account_id=acc_id,[m
[32m+[m[32m                    symbol_id=symbol_id,[m
[32m+[m[32m                    trade_id=str(trade_id),[m
[32m+[m[32m                    order_id=order_id,[m
[32m+[m[32m                    side=side,[m
[32m+[m[32m                    price=float(_f(o.get("L"), 0.0) or 0.0),[m
[32m+[m[32m                    qty=float(last_qty),[m
[32m+[m[32m                    realized_pnl=_f(o.get("rp"), 0.0),[m
[32m+[m[32m                    fee=_f(o.get("n"), 0.0),[m
[32m+[m[32m                    fee_asset=str(o.get("N") or ""),[m
[32m+[m[32m                    source=source,[m
[32m+[m[32m                    ts_ms=ts_ms,[m
[32m+[m[32m                    raw=event,[m
[32m+[m[32m                )[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        return out[m
[32m+[m
[32m+[m[32m    # ------------------------------------------------------------[m
[32m+[m[32m    # Spot user stream: executionReport (best-effort)[m
[32m+[m[32m    # ------------------------------------------------------------[m
[32m+[m[32m    if et == "EXECUTIONREPORT":[m
[32m+[m[32m        symbol = str(event.get("s") or "").upper()[m
[32m+[m[32m        if not symbol:[m
[32m+[m[32m            return out[m
[32m+[m[32m        symbol_id = int(sym_ids.get(symbol) or 0)[m
[32m+[m
[32m+[m[32m        ts_ms = _to_int_ms(event.get("T") or event.get("E"))[m
[32m+[m[32m        order_id = str(event.get("i") or "")[m
[32m+[m[32m        client_order_id = str(event.get("c") or "") or None[m
[32m+[m
[32m+[m[32m        status = str(event.get("X") or "").upper()[m
[32m+[m[32m        side = str(event.get("S") or "").upper() or None[m
[32m+[m[32m        typ = str(event.get("o") or "").upper() or None[m
[32m+[m[32m        reduce_only = False[m
[32m+[m
[32m+[m[32m        qty = _f(event.get("q"), None)[m
[32m+[m[32m        filled_qty = _f(event.get("z"), None)[m
[32m+[m[32m        price = _f(event.get("p"), None)[m
[32m+[m[32m        if price is not None and price == 0.0:[m
[32m+[m[32m            price = None[m
[32m+[m
         out.append([m
[31m-            TradeEvent([m
[32m+[m[32m            OrderEvent([m
                 exchange=exchange,[m
                 account=account,[m
[31m-                symbol=o["s"],[m
[31m-                trade_id=int(o["t"]),[m
[31m-                order_id=int(o["i"]),[m
[31m-                side=o["S"],[m
[31m-                price=float(o["L"]),[m
[31m-                qty=float(o["l"]),[m
[31m-                realized_pnl=float(o.get("rp") or 0),[m
[31m-                fee=float(o.get("n") or 0),[m
[31m-                fee_asset=o.get("N") or "",[m
[31m-                event_ts=ts,[m
[32m+[m[32m                symbol=symbol,[m
[32m+[m[32m                exchange_id=ex_id,[m
[32m+[m[32m                account_id=acc_id,[m
[32m+[m[32m                symbol_id=symbol_id,[m
[32m+[m[32m                order_id=order_id,[m
[32m+[m[32m                client_order_id=client_order_id,[m
[32m+[m[32m                status=status,[m
[32m+[m[32m                side=side,[m
[32m+[m[32m                type=typ,[m
[32m+[m[32m                reduce_only=reduce_only,[m
[32m+[m[32m                price=price,[m
[32m+[m[32m                qty=qty,[m
[32m+[m[32m                filled_qty=filled_qty,[m
[32m+[m[32m                source=source,[m
[32m+[m[32m                ts_ms=ts_ms,[m
[32m+[m[32m                raw=event,[m
             )[m
         )[m
 [m
[32m+[m[32m        last_qty = _f(event.get("l"), 0.0) or 0.0[m
[32m+[m[32m        trade_id = event.get("t")[m
[32m+[m[32m        if trade_id is not None and last_qty and float(last_qty) > 0:[m
[32m+[m[32m            out.append([m
[32m+[m[32m                TradeEvent([m
[32m+[m[32m                    exchange=exchange,[m
[32m+[m[32m                    account=account,[m
[32m+[m[32m                    symbol=symbol,[m
[32m+[m[32m                    exchange_id=ex_id,[m
[32m+[m[32m                    account_id=acc_id,[m
[32m+[m[32m                    symbol_id=symbol_id,[m
[32m+[m[32m                    trade_id=str(trade_id),[m
[32m+[m[32m                    order_id=order_id,[m
[32m+[m[32m                    side=side,[m
[32m+[m[32m                    price=float(_f(event.get("L"), 0.0) or 0.0),[m
[32m+[m[32m                    qty=float(last_qty),[m
[32m+[m[32m                    realized_pnl=None,[m
[32m+[m[32m                    fee=_f(event.get("n"), 0.0),[m
[32m+[m[32m                    fee_asset=str(event.get("N") or ""),[m
[32m+[m[32m                    source=source,[m
[32m+[m[32m                    ts_ms=ts_ms,[m
[32m+[m[32m                    raw=event,[m
[32m+[m[32m                )[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        return out[m
[32m+[m
     return out[m
[1mdiff --git a/src/platform/core/oms/writer.py b/src/platform/core/oms/writer.py[m
[1mindex 56fc1fa..e215eeb 100644[m
[1m--- a/src/platform/core/oms/writer.py[m
[1m+++ b/src/platform/core/oms/writer.py[m
[36m@@ -15,6 +15,36 @@[m [mclass OmsWriter:[m
         self.logger = logger or logging.getLogger(__name__)[m
         self.sm = OrderStateMachine()[m
 [m
[32m+[m
[32m+[m[32m    def _append_order_event(self, order_evt: OrderEvent) -> None:[m
[32m+[m[32m        """STEP G.1: append raw order events into DB (idempotent insert)."""[m
[32m+[m[32m        try:[m
[32m+[m[32m            if not hasattr(self.storage, "append_order_events"):[m
[32m+[m[32m                return[m
[32m+[m[32m            now = datetime.now(tz=timezone.utc)[m
[32m+[m[32m            row = {[m
[32m+[m[32m                "exchange_id": int(order_evt.exchange_id),[m
[32m+[m[32m                "account_id": int(order_evt.account_id),[m
[32m+[m[32m                "order_id": str(order_evt.order_id),[m
[32m+[m[32m                "symbol_id": int(order_evt.symbol_id),[m
[32m+[m[32m                "client_order_id": str(order_evt.client_order_id or ""),[m
[32m+[m[32m                "status": str(order_evt.status or ""),[m
[32m+[m[32m                "side": str(order_evt.side or ""),[m
[32m+[m[32m                "type": str(order_evt.type or ""),[m
[32m+[m[32m                "reduce_only": bool(order_evt.reduce_only),[m
[32m+[m[32m                "price": float(order_evt.price) if order_evt.price is not None else None,[m
[32m+[m[32m                "qty": float(order_evt.qty or 0.0) if order_evt.qty is not None else None,[m
[32m+[m[32m                "filled_qty": float(order_evt.filled_qty or 0.0) if order_evt.filled_qty is not None else None,[m
[32m+[m[32m                "source": str(order_evt.source or "ws_user"),[m
[32m+[m[32m                "ts_ms": int(order_evt.ts_ms or 0),[m
[32m+[m[32m                "recv_ts": now,[m
[32m+[m[32m                "raw_json": json.dumps(order_evt.raw or {}, ensure_ascii=False, default=str),[m
[32m+[m[32m            }[m
[32m+[m[32m            self.storage.append_order_events([row])[m
[32m+[m[32m        except Exception:[m
[32m+[m[32m            self.logger.exception("[OMS][ORDER_EVENT] append failed")[m
[32m+[m
[32m+[m
     def write_order(self, order_evt: OrderEvent | None) -> None:[m
         if order_evt is None:[m
             return[m
[1mdiff --git a/src/platform/data/storage/base.py b/src/platform/data/storage/base.py[m
[1mindex 292df43..f26ab5a 100644[m
[1m--- a/src/platform/data/storage/base.py[m
[1m+++ b/src/platform/data/storage/base.py[m
[36m@@ -84,6 +84,9 @@[m [mclass Storage(ABC):[m
     @abstractmethod[m
     def upsert_order_fills(self, rows: Iterable[dict]) -> None: ...[m
 [m
[32m+[m[32m    @abstractmethod[m
[32m+[m[32m    def append_order_events(self, rows: Iterable[dict]) -> None: ...[m
[32m+[m
     @abstractmethod[m
     def upsert_candles(self, rows: Iterable[dict]) -> None: ...[m
 [m
[1mdiff --git a/src/platform/data/storage/postgres/ddl.sql b/src/platform/data/storage/postgres/ddl.sql[m
[1mindex 977a472..a3f9517 100644[m
[1m--- a/src/platform/data/storage/postgres/ddl.sql[m
[1m+++ b/src/platform/data/storage/postgres/ddl.sql[m
[36m@@ -70,6 +70,30 @@[m [mCREATE TABLE IF NOT EXISTS orders ([m
 CREATE INDEX IF NOT EXISTS idx_orders_client_oid ON orders(exchange_id, account_id, client_order_id);[m
 CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(exchange_id, account_id, status);[m
 [m
[32m+[m
[32m+[m[32mCREATE TABLE IF NOT EXISTS order_events ([m
[32m+[m[32m  exchange_id SMALLINT NOT NULL,[m
[32m+[m[32m  account_id SMALLINT NOT NULL,[m
[32m+[m[32m  order_id TEXT NOT NULL,[m
[32m+[m[32m  symbol_id BIGINT NOT NULL,[m
[32m+[m[32m  client_order_id TEXT,[m
[32m+[m[32m  status TEXT NOT NULL,[m
[32m+[m[32m  side TEXT,[m
[32m+[m[32m  type TEXT,[m
[32m+[m[32m  reduce_only BOOLEAN,[m
[32m+[m[32m  price NUMERIC(18,8),[m
[32m+[m[32m  qty NUMERIC(18,8),[m
[32m+[m[32m  filled_qty NUMERIC(18,8),[m
[32m+[m[32m  source TEXT DEFAULT 'ws_user',[m
[32m+[m[32m  ts_ms BIGINT NOT NULL,[m
[32m+[m[32m  recv_ts TIMESTAMPTZ NOT NULL,[m
[32m+[m[32m  raw_json TEXT,[m
[32m+[m[32m  -- idempotency key: same order_id + ts_ms + status + filled_qty won't be inserted twice[m
[32m+[m[32m  UNIQUE(exchange_id, account_id, order_id, ts_ms, status, filled_qty)[m
[32m+[m[32m);[m
[32m+[m[32mCREATE INDEX IF NOT EXISTS idx_order_events_oid ON order_events(exchange_id, account_id, order_id);[m
[32m+[m[32mCREATE INDEX IF NOT EXISTS idx_order_events_ts  ON order_events(exchange_id, account_id, ts_ms);[m
[32m+[m
 CREATE TABLE IF NOT EXISTS trades ([m
   exchange_id SMALLINT NOT NULL,[m
   account_id SMALLINT NOT NULL,[m
[1mdiff --git a/src/platform/data/storage/postgres/storage.py b/src/platform/data/storage/postgres/storage.py[m
[1mindex 799bd1b..df837e7 100644[m
[1m--- a/src/platform/data/storage/postgres/storage.py[m
[1m+++ b/src/platform/data/storage/postgres/storage.py[m
[36m@@ -786,6 +786,34 @@[m [mclass PostgreSQLStorage:[m
                 )[m
             conn.commit()[m
 [m
[32m+[m
[32m+[m[32m    def append_order_events(self, rows: Iterable[dict]) -> None:[m
[32m+[m[32m        """Append immutable order events (idempotent)."""[m
[32m+[m[32m        rows = list(rows or [])[m
[32m+[m[32m        if not rows:[m
[32m+[m[32m            return[m
[32m+[m
[32m+[m[32m        query = """[m
[32m+[m[32m            INSERT INTO order_events ([m
[32m+[m[32m                exchange_id, account_id, order_id, symbol_id,[m
[32m+[m[32m                client_order_id, status, side, type, reduce_only,[m
[32m+[m[32m                price, qty, filled_qty,[m
[32m+[m[32m                source, ts_ms, recv_ts, raw_json[m
[32m+[m[32m            )[m
[32m+[m[32m            VALUES ([m
[32m+[m[32m                %(exchange_id)s, %(account_id)s, %(order_id)s, %(symbol_id)s,[m
[32m+[m[32m                %(client_order_id)s, %(status)s, %(side)s, %(type)s, %(reduce_only)s,[m
[32m+[m[32m                %(price)s, %(qty)s, %(filled_qty)s,[m
[32m+[m[32m                %(source)s, %(ts_ms)s, %(recv_ts)s, %(raw_json)s[m
[32m+[m[32m            )[m
[32m+[m[32m            ON CONFLICT DO NOTHING[m
[32m+[m[32m        """[m
[32m+[m
[32m+[m[32m        with self.pool.connection() as conn:[m
[32m+[m[32m            with conn.cursor() as cur:[m
[32m+[m[32m                cur.executemany(query, rows)[m
[32m+[m[32m            conn.commit()[m
[32m+[m
     def upsert_candles(self, rows: list[dict]) -> int:[m
         """[m
         Bulk upsert candles into public.candles.[m
