# config/trade_liquidation.yaml
# ==========================================================
# TRADE LIQUIDATION (trader по сигналам scr_liquidation_binance)
#
# Назначение:
#   - Берёт свежие сигналы из таблицы signals (по скринеру scr_liquidation_binance)
#   - В LIVE режиме открывает позицию на Binance USDⓈ-M Futures
#   - Ставит защитные ордера SL/TP (если включено)
#   - Поддерживает добор позиции (DCA) на значимых уровнях HTF (1h/4h)
#   - При включённом DCA может отложить постановку SL до последнего добора
#
# Запуск (PowerShell):
#   $env:PG_DSN="host=localhost port=5432 dbname=trade_platform user=postgres sslmode=prefer connect_timeout=10"
#   $env:TRADE_LIQUIDATION_CONFIG="config/trade_liquidation.yaml"
#   $env:DRY_RUN="0"
#   python -m src.platform.run_trade_liquidation
# ==========================================================


restart_interval_minutes: 0.2      # Интервал между циклами run_once (в минутах).
                                   # 0.25 = 15 секунд. Чем меньше — тем быстрее реакция, но выше нагрузка.

traders:
  - name: trade_liquidation         # Имя трейдера (как будет отображаться в логах)
    enabled: true                   # Включить/выключить запуск этого трейдера
    version: "1.0"                  # Версия конфига/бота (для логов и контроля изменений)

    params:
      # ======================================================
      # ИСТОЧНИК СИГНАЛОВ (signals)
      # ======================================================
      exchange_id: 1                # ID биржи в БД (Binance = 1)
      account_name: "BASE"          # Имя аккаунта в таблице accounts (если account_id не задан)
      account_id: 1                 # ID аккаунта (если задан — используется напрямую)

      screener_name: "scr_liquidation_binance"   # Из какого скринера берём сигналы (JOIN screeners)
      signal_status_new: "NEW"                   # Берём только сигналы с этим статусом
                                                 # Важно: статус должен быть в enum signal_status.

      allowed_timeframes: ["15m", "1h", "4h"]     # Разрешённые ТФ сигнала. Если сигнал другого ТФ — пропускаем.

      # Свежесть сигнала:
      max_signal_age_minutes: 30                 # Берём сигналы, которым не больше N минут (строгий фильтр).
                                                 # В коде может учитываться close-time свечи: signal_ts + TF.

      # Анти-спам по символу:
      per_symbol_cooldown_minutes: 90            # Если по этому symbol уже открывали позицию недавно (по position_ledger),
                                                 # то повторно не открываем до истечения N минут.

      # ======================================================
      # АНТИ-БЕСКОНЕЧНЫЕ ПОВТОРЫ ОДНОГО СИГНАЛА (через signals.context)
      # ======================================================
      max_attempts_per_signal: 3                 # Сколько раз максимум пытаться открыть один и тот же сигнал.
                                                 # После превышения — переводим сигнал в expire_status (если включено).

      retry_cooldown_minutes: 5                  # Пауза между попытками по одному сигналу (мин).
                                                 # Если последняя попытка была недавно — сигнал пропускаем.

      attempts_context_key: "trade_liquidation"  # Ключ в signals.context (jsonb), где хранится attempts/last_attempt_ts.
                                                 # Пример: context->'trade_liquidation'->'attempts'.

      expire_on_attempts_exceeded: true          # true => если attempts >= max_attempts_per_signal, то сигнал помечаем expire_status.
      expire_status: "EXPIRED"                  # Статус для "сгоревших" сигналов (обязан быть в enum signal_status).
                                                 # По твоему enum: NEW / TAKEN / CANCELLED / EXPIRED / LOCKED.

      # ======================================================
      # АВТО-ЭКСПИРАЦИЯ СТАРЫХ NEW СИГНАЛОВ (ЧИСТКА)
      # ======================================================
      expire_old_signals: true                   # true => в каждом цикле помечаем старые NEW сигналы как EXPIRED.
      expire_max_age_minutes: 240                # Если null/0 => используем max_signal_age_minutes.
                                                 # Если задано число — это отдельный порог для чистки.
      expire_batch_limit: 5000                   # Сколько строк максимум обновлять за один цикл (защита от тяжёлых UPDATE).
                                                 # 0 => без лимита (не рекомендую на больших таблицах).

      # ======================================================
      # РЕЖИМ РАБОТЫ
      # ======================================================
      mode: "live"                               # "paper" = эмуляция, "live" = реальные ордера на бирже.

      # ======================================================
      # LIVE: API KEYS (берём из ENV/.env)
      # ======================================================
      api_key_env: "BINANCE_BASE_MAIN_API_KEY"       # Имя переменной окружения с API Key
      api_secret_env: "BINANCE_BASE_MAIN_API_SECRET" # Имя переменной окружения с API Secret

      base_url: "https://fapi.binance.com"       # Базовый URL Binance Futures (USD-M)
      recv_window_ms: 5000                       # recvWindow для Binance (мс) — допуск по времени запроса
      timeout_sec: 10                            # Таймаут HTTP запросов (сек)

      # Баланс:
      use_exchange_balance: true                 # true => баланс берём напрямую с биржи (REST /fapi/v2/balance, USDT walletBalance).
                                                 # false => баланс берём из БД (account_balance_snapshots).

      # Плечо/маржа (best-effort):
      leverage: 10                               # Плечо (если биржа позволяет изменить через API). null => не трогаем.
      margin_type: "CROSSED"                     # "ISOLATED" | "CROSSED" | null
                                                 # null => не меняем. На некоторых символах смена может вернуть ошибку — это ок.

      # Режим позиции:
      hedge_enabled: true                        # true => Hedge Mode (positionSide=LONG/SHORT)
                                                 # false => One-way (без positionSide)

      # ======================================================
      # ЛИМИТЫ
      # ======================================================
      max_open_positions: 6                      # Максимум одновременно открытых позиций по этой стратегии (position_ledger status='OPEN').
      max_position_notional_pct_wallet: 20.0     # Максимальный номинал одной позиции как % от кошелька (walletBalance).
                                                 # Например, wallet=1000 USDT и 50% => не больше 500 USDT в одной позиции.

      # ======================================================
      # РИСК / SL / TP
      # ======================================================
      risk_wallet_pct: 2.0                       # Риск на сделку (% от кошелька). Используется для расчёта notional через SL%.
      stop_loss_pct: 2.0                         # Дистанция SL в процентах от entry (если recalc_sl_tp=true).
      take_profit_pct: 6.0                       # Дистанция TP в процентах от entry (если recalc_sl_tp=true).
      recalc_sl_tp: true                         # true => SL/TP пересчитываем от entry_price,
                                                 # false => берём stop_loss/take_profit из сигнала (если есть).

      # ======================================================
      # LIVE: ТИПЫ ОРДЕРОВ
      # ======================================================
      entry_order_type: "market"                 # Тип входа (в текущей реализации обычно market)
      sl_order_mode: "trailing_stop_market"               # stop_market | trailing_stop_market
                                                 # trailing_stop_market сработает только если включён trailing_enabled=true.

      tp_order_mode: "take_profit_market"        # take_profit_market (обычно закрытие позиции по условию)

      reduce_only: true                          # reduceOnly для защитных/закрывающих ордеров (в one-way полезно)
      working_type: "MARK_PRICE"                 # Рабочая цена для триггеров: MARK_PRICE или CONTRACT_PRICE (если поддерживается)
      time_in_force: "GTC"                       # Для LIMIT-ордеров (например DCA limit): GTC/IOC/FOK (GTC чаще всего)

      client_order_id_prefix: "TL"               # Префикс clientOrderId.
                                                 # Важно: Binance ограничивает clientOrderId по длине (<36).

      # ======================================================
      # БЕЗОПАСНОСТЬ: РУЧНОЕ УПРАВЛЕНИЕ SL/TP + ОБРАБОТКА ОШИБОК BRACKET
      # ======================================================
      enable_stop_loss: true                     # Включить/выключить постановку стоп-лосса вообще.
      enable_take_profit: true                   # Включить/выключить постановку тейк-профита вообще.

      defer_stop_loss_until_last_add: true       # Если включён DCA — можно НЕ ставить SL при первичном входе,
                                                 # а поставить только после последнего добора (после averaging_max_adds).

      sl_after_last_add_distance_pct: 2.0        # SL после последнего добора: расстояние (% от цены последнего добора).
                                                 # LONG: SL ниже last_add_price на N%
                                                 # SHORT: SL выше last_add_price на N%

      abort_on_bracket_fail: true                # Если ожидали SL/TP, но они не выставились -> считаем критично.
      close_on_bracket_fail: true                # При критичном фейле пытаемся закрыть позицию MARKET (best-effort).
      signal_status_on_bracket_fail: "CANCELLED" # Статус сигнала при bracket-fail, чтобы не ретраить бесконечно.
                                                 # Должен быть enum-safe: CANCELLED или EXPIRED.

      # ======================================================
      # TRAILING (используется, если sl_order_mode="trailing_stop_market")
      # ======================================================
      trailing_enabled: true                     # Разрешить трейлинг-стоп
      trailing_activation_pct: 5.0               # Активация трейлинга: на сколько % цена должна уйти в прибыль, чтобы включился трейлинг
      trailing_trail_pct: 1.0                    # callbackRate Binance (%). Обычно 0.1..5.0 (зависит от правил биржи)

      # ==========================================================
      # УСРЕДНЕНИЕ (DCA) НА ЗНАЧИМЫХ УРОВНЯХ HTF (1h/4h)
      # ==========================================================
      averaging_enabled: false
      # Включить/выключить механику доборов

      averaging_max_adds: 2                      # Сколько раз максимум делать добор после первичного входа.
                                                 # Когда adds_done достигнет этого числа и defer_stop_loss_until_last_add=true,
                                                 # бот поставит SL от цены последнего добора.

      averaging_add_size_mode: "risk_pct"      # fixed_usdt | risk_pct
                                                 # fixed_usdt => размер добора = averaging_add_size_value в USDT
                                                 # risk_pct   => размер добора = averaging_add_size_value % от walletBalance

      averaging_add_size_value: 20               # Значение размера добора:
                                                 # - fixed_usdt: 50 => докупить на 50 USDT
                                                 # - risk_pct:   5  => докупить на 5% от walletBalance

      averaging_order_type: "market"             # market | limit
                                                 # market => добор сразу по рынку при касании уровня
                                                 # limit  => выставляем лимитку по цене уровня

      # --- Уровни для добора (HTF) ---
      averaging_levels_tf: "1h"                  # Таймфрейм уровней: "1h" или "4h"
      averaging_levels_lookback_hours: 720       # Период истории для поиска уровней (в часах). 168 = 7 дней.
      averaging_levels_method: "combined"        # pivots | volume_profile | combined
                                                 # pivots         => уровни из swing-пивотов (локальные экстремумы)
                                                 # volume_profile => уровни из горизонтального профиля объёма (volume nodes)
                                                 # combined       => объединение pivots + volume_profile, затем кластеризация

      averaging_level_tolerance_pct: 0.15        # Допуск "касания" уровня (в % от текущей цены).
                                                 # Например 0.15 => достаточно приблизиться на 0.15%, чтобы считать касание.

      # --- Настройки volume profile ---
      averaging_vp_bins: 48                      # Кол-во бинов (корзин) по цене для профиля объёма
      averaging_vp_top_nodes: 10                 # Сколько самых “тяжёлых” уровней (по объёму) брать из профиля

      # --- Настройки pivot/swing ---
      averaging_pivot_left: 3                    # Сколько свечей слева для подтверждения pivot (swing)
      averaging_pivot_right: 3                   # Сколько свечей справа для подтверждения pivot

      # --- Кластеризация уровней ---
      averaging_cluster_tolerance_pct: 0.25      # Если уровни близко друг к другу (<=0.25%) — объединяем в один средний уровень

      # ======================================================
      # DEBUG
      # ======================================================
      debug: true                                # Включить подробные debug-логи
      debug_top: 10                              # Сколько элементов показывать в некоторых debug-выводах (top-N)

      # ======================================================
      # PORTFOLIO CAP + RECONCILE + RECOVERY (LIVE SAFETY)
      # ======================================================
      portfolio_cap_ratio: 0.7                  # 0=OFF. Если SUM(position_ledger.position_value_usdt WHERE OPEN)/wallet >= ratio -> не открываем новые сделки.
                                                # Пример: 0.7 = не превышать 70% от баланса; 1.0 = не превышать 1x wallet.

      reconcile_enabled: true                   # Сверка ledger ↔ Binance (positionRisk) каждый цикл
      reconcile_qty_tolerance: 1e-8             # Толеранс по qty: меньше -> считаем как 0
      reconcile_auto_close_ledger: true         # Если Binance позиция=0, а ledger OPEN -> автоматически закрыть запись в ledger
      reconcile_every_n_cycles: 3
      reconcile_log_diffs: true
      reconcile_import_binance_positions: true
      reconcile_ignore_external_positions: true   # Не считаем ошибкой, если на Binance есть позиции не из ledger
      reconcile_external_log_level: "debug"       # "debug" | "info" | "warning"

      margin_cap_include_external_positions: true

      auto_recovery_enabled: true               # Авто-восстановление SL/TP при рестарте/каждый цикл, если защитных ордеров нет
      recovery_place_sl: true                   # Восстанавливать SL
      recovery_place_tp: true                   # Восстанавливать TP
      recovery_max_age_hours: 48                # Не трогаем очень старые позиции (безопасность)

      async_rest_enabled: false                 # Параллелить REST-запросы (ускорение цикла). Включай после теста.
      async_rest_workers: 4                     # Кол-во worker потоков (если async_rest_enabled=true)




